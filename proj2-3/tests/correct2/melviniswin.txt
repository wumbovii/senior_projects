
FILENAME: multiassign.py

 CODE:
x, y = 2, 3


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
y			GLOBAL_VAR	-> 31

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
looking for decl for y
adding global var y
found decl for y
top of decorate
top of decorate
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
INT allowed: 4
INT category: 4
top of type inference
INT allowed: 4
INT category: 4
before: 0
before: 32
before: 0
before: 32
after: 0
after: 32
after: 0
after: 32


DAST OF multiassign.py

(module 0
    (assign 1
        (target_list 1
            (id 1 x)
            (id 1 y))
        (tuple 1
            (int_literal 1 2)
            (int_literal 1 3))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type_var 0 (id 0 $_24)))

(globaldecl 31 y 0
(type_var 0 (id 0 $_25)))


FILENAME: decl_selfinstances.py

 CODE:
class Coord(parent):
    def __init__(self, xcor, ycor):
        self.x = xcor
        self.y = ycor

    def print1(self):
        print self.x
        print self.y

    def print2(self, x, y):
        print x
        print y


    def dist(self):
        x = 4
        y = 3
        def square():
           x = x*x
           y = y*y
           return x+y
        square()



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
Coord			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init__			FUNC_DEC	-> 32
xcor			PARAM_VAR	-> 33
ycor			PARAM_VAR	-> 34
x			INSTANCE_VAR	-> 35
y			INSTANCE_VAR	-> 36
print1			FUNC_DEC	-> 37
print2			FUNC_DEC	-> 38
x			PARAM_VAR	-> 39
y			PARAM_VAR	-> 40
dist			FUNC_DEC	-> 41
x			LOCAL_VAR	-> 42
y			LOCAL_VAR	-> 43
square			FUNC_DEC	-> 44
x			LOCAL_VAR	-> 45
y			LOCAL_VAR	-> 46

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for Coord
found decl for Coord
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: decl_interleaved.py

 CODE:

global_var = 1
global_typed::int = 1
class class_external(parent):
    
    instance_var1 = 1
    instanced_typed1::int = 1

    def func_def(self):
        local_var = 1
        local_typed::int = 1

    instance_var2 = 1
    instance_typed::int = 1

    def func_def_with_params(self):
        local_var = 1

    def func_def_with_multiparam(self, x, y, z):
        pass

    def func_def_with_typedparam(self, x::int):
        pass

    def func_def_nest1(self):
        local_nest1 = 1
        def func_def_nest2():
            pass
        local_nest2 = 1



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
getting param 3
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
global_var			GLOBAL_VAR	-> 30
global_typed			GLOBAL_VAR	-> 31
class_external			CLASS_DEC	-> 32
self			INSTANCE_VAR	-> 33
instance_var1			INSTANCE_VAR	-> 34
instanced_typed1			INSTANCE_VAR	-> 35
func_def			FUNC_DEC	-> 36
local_var			LOCAL_VAR	-> 37
local_typed			LOCAL_VAR	-> 38
instance_var2			INSTANCE_VAR	-> 39
instance_typed			INSTANCE_VAR	-> 40
func_def_with_params			FUNC_DEC	-> 41
local_var			LOCAL_VAR	-> 42
func_def_with_multiparam			FUNC_DEC	-> 43
x			PARAM_VAR	-> 44
y			PARAM_VAR	-> 45
z			PARAM_VAR	-> 46
func_def_with_typedparam			FUNC_DEC	-> 47
x			PARAM_VAR	-> 48
func_def_nest1			FUNC_DEC	-> 49
local_nest1			LOCAL_VAR	-> 50
func_def_nest2			FUNC_DEC	-> 51
local_nest2			LOCAL_VAR	-> 52

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for global_var
adding global var global_var
found decl for global_var
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for global_typed
adding global var global_typed
found decl for global_typed
top of decorate
looking for decl for global_typed
found decl for global_typed

FILENAME: testDeclare.py

 CODE:
#simple declaration test
x = 5


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4


DAST OF testDeclare.py

(module 0
    (assign 2
        (id 2 x)
        (int_literal 2 5)))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type 0
        (id 0 int)
        (type_list 0)))


FILENAME: testLambda2.py

 CODE:
#tests lambda in def
def make_incrementor(self, n):
    return lambda x: x +n

f = make_incrementor(42);
print f(0)
print f(1)


COMMAND OUTPUT

DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
getting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
make_incrementor			FUNC_DEC	-> 30
n			PARAM_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
f			GLOBAL_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for make_incrementor
found decl for make_incrementor
scoping in from def, new decl region is: make_incrementor
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
looking for decl for n
found decl for n
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
top of decorate
top of decorate
looking for decl for f
adding global var f
found decl for f
top of decorate
top of decorate
looking for decl for make_incrementor
found decl for make_incrementor
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
top of decorate
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0

FILENAME: testAllocator2.py

 CODE:
#test multiple allocations of a single class with __init__
class EngineerClass(object):
    def __init__(self):
        self.weapon = "SCAR-H"
        self.gadget = "SMAW"

myEngineer1 = EngineerClass()
myEngineer2 = EngineerClass()
myEngineer3 = EngineerClass()
myEngineer4 = EngineerClass()


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
EngineerClass			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init__			FUNC_DEC	-> 32
weapon			INSTANCE_VAR	-> 33
gadget			INSTANCE_VAR	-> 34
myEngineer1			GLOBAL_VAR	-> 35
myEngineer2			GLOBAL_VAR	-> 36
myEngineer3			GLOBAL_VAR	-> 37
myEngineer4			GLOBAL_VAR	-> 38

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for EngineerClass
found decl for EngineerClass
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: testLambda3.py

 CODE:
class Marine(o):
        
    def balance(self):
        lambda x: x


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






xSelf is not first param: ERRORPARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
Marine			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
balance			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for Marine
found decl for Marine
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
looking for decl for balance
found decl for balance
scoping in from def, new decl region is: balance
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda3.py

(module 0
    (class 1
        (id 1 Marine)
        (id 1 o)
        (block 3
            (def 0
                (id 0 __lambda0__)
                (formals_list 4
                    (id 4 x))
                ()
                (block 4
                    (id 4 x)))
            (def 3
                (id 3 balance)
                (formals_list 3
                    (id 3 self))
                ()
                (block 4
                    (id 0 __lambda0__))))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 Marine 0
(type_var 0 (id 0 $_28))
(index_list 31 32 34))

(instancedecl 31 self 30
(type 0))

(funcdecl 32 __lambda0__ 30
(type_var 0 (id 0 $_32))
(index_list 33))

(paramdecl 33 x 32 0
(type_var 0 (id 0 $_30)))

(funcdecl 34 balance 30
(type_var 0 (id 0 $_31)))


FILENAME: testAllocator3.py

 CODE:
#test multiple allocations of various classes with __init__, including reassignments and allocations
class SupportClass(object):
    def __init__(self, team):
        self.weapon = "M249 SAW"
        self.gadget = "AmmoKit"
        self.team = team

class ReconClass(object):
    def __init__(self, team):
        self.weapon = "MK11"
        self.gadget = "RadioBeacon"
        self.team = team
        
mySupport1 = SupportClass("USMC")
mySupport2 = SupportClass("OpFor")
myRecon1 = ReconClass("USMC")
myRecon2 = ReconClass("OpFor")

#reassignments
mySupport1 = SupportClass("OpFor")
myRecon2 = ReconClass("USMC")


COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
SupportClass			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init__			FUNC_DEC	-> 32
team			PARAM_VAR	-> 33
weapon			INSTANCE_VAR	-> 34
gadget			INSTANCE_VAR	-> 35
team			INSTANCE_VAR	-> 36
ReconClass			CLASS_DEC	-> 37
self			INSTANCE_VAR	-> 38
__init__			FUNC_DEC	-> 39
team			PARAM_VAR	-> 40
weapon			INSTANCE_VAR	-> 41
gadget			INSTANCE_VAR	-> 42
team			INSTANCE_VAR	-> 43
mySupport1			GLOBAL_VAR	-> 44
mySupport2			GLOBAL_VAR	-> 45
myRecon1			GLOBAL_VAR	-> 46
myRecon2			GLOBAL_VAR	-> 47

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for SupportClass
found decl for SupportClass
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: testAllocator4.py

 CODE:
#simple allocator test with NO __init__, multiple allocations of multiple classes
class iPhone4(object):
    def hasSiri(self):
        return False
        
class iPhone4S(object):
    def hasSir(self):
        return True

myPhone1 = iPhone4()
myPhone2 = iPhone4S()
myPhone3 = iPhone4()
myPhone4 = iPhone4S()
myPhone5 = iPhone4()
myPhone6 = iPhone4S()


COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
iPhone4			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
hasSiri			FUNC_DEC	-> 32
iPhone4S			CLASS_DEC	-> 33
self			INSTANCE_VAR	-> 34
hasSir			FUNC_DEC	-> 35
myPhone1			GLOBAL_VAR	-> 36
myPhone2			GLOBAL_VAR	-> 37
myPhone3			GLOBAL_VAR	-> 38
myPhone4			GLOBAL_VAR	-> 39
myPhone5			GLOBAL_VAR	-> 40
myPhone6			GLOBAL_VAR	-> 41

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for iPhone4
found decl for iPhone4
top of decorate
top of decorate
top of decorate
looking for decl for hasSiri
found decl for hasSiri
scoping in from def, new decl region is: hasSiri
top of decorate
top of decorate
top of decorate
looking for decl for False

FILENAME: testAllocator5.py

 CODE:
#test multiple allocations with method calls in between
class Marine(object):
    def __init__(self):
        self.dmg = 6;
        self.health = 45;
        self.op = True;
        
    def balance(self):
        patch = lambda x: x -1
        self.dmg = patch(self.dmg)
        self.op = False
        
    def attack(self, unit):
        print "marine attacked!"
        
class Zealot(object):
    def __init__(self):
        self.dmg = 16
        self.health = 80
        self.shield = 80
        self.op = False
    
    def charge(self, unit):
        print "zealot charged!"
        self.op = True

myMarine = Marine()
myMarine.balance()
myMarine.attack(myMarine)
myZealot = Zealot()
myZealot.charge(myMarine)
myMarine.attack(myZealot)
myMarine.attack(myZealot)
myZealot2 = Zealot()
myZealot = Zealot()
myMarine = Marine()


COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






xSelf is not first param: ERRORPARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
Marine			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
__init__			FUNC_DEC	-> 34
dmg			INSTANCE_VAR	-> 35
health			INSTANCE_VAR	-> 36
op			INSTANCE_VAR	-> 37
balance			FUNC_DEC	-> 38
patch			LOCAL_VAR	-> 39
attack			FUNC_DEC	-> 40
unit			PARAM_VAR	-> 41
Zealot			CLASS_DEC	-> 42
self			INSTANCE_VAR	-> 43
__init__			FUNC_DEC	-> 44
dmg			INSTANCE_VAR	-> 45
health			INSTANCE_VAR	-> 46
shield			INSTANCE_VAR	-> 47
op			INSTANCE_VAR	-> 48
charge			FUNC_DEC	-> 49
unit			PARAM_VAR	-> 50
myMarine			GLOBAL_VAR	-> 51
myZealot			GLOBAL_VAR	-> 52
myZealot2			GLOBAL_VAR	-> 53

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for Marine
found decl for Marine
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: decl_samevarnames.py

 CODE:

x = 2

class x(parent):
    
    x = 6

    def x(self):
        x = 6

    x = 11

    def func_def_with_params(self, x):
        pass

    def func_def_with_multiparam(self, x, y, z):
        x = 17

    def func_def_with_typedparam(self, x::int):
        pass

    def func_def_nest1(self, x):

        def x():
            pass




COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
CLASS SYNTAX

FILENAME: trivial.py

 CODE:
def hi():
    def hi():
        print 4
    hi()
hi()

COMMAND OUTPUT


FILENAME: testLambda.py

 CODE:
x = [2, 3, 6]

print filter(lambda x: x % 3 == 0, x)


COMMAND OUTPUT

DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
__lambda0__			FUNC_DEC	-> 30
x			PARAM_VAR	-> 31
x			GLOBAL_VAR	-> 32

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
looking for decl for ==


DAST OF testLambda.py

(module 0
    (assign 1
        (id 1 x)
        (list_display 1
            (int_literal 1 2)
            (int_literal 1 3)
            (int_literal 1 6)))
    (println 3
        ()
        (expr_list 3
            (call 3
                (id 3 filter)
                (expr_list 3
                    (id 0 __lambda0__)
                    (id 3 x))))))
(moduledecl 0 __main__

(index_list 30))

(moduledecl 1 __builtin__

(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
)

(classdecl 3 bool 1
)

(classdecl 4 file 1
)

(classdecl 5 str 1
)

(classdecl 6 range 1
)

(classdecl 7 list 1
)

(classdecl 8 tuple 1
)

(classdecl 9 dict 1
)

(constdecl 10 None 1
)

(constdecl 11 True 1
)

(constdecl 12 False 1
)

(constdecl 13 stdout 1
)

(constdecl 14 stdin 1
)

(constdecl 15 stderr 1
)

(constdecl 16 argv 1
)

(constdecl 17 for 1
)

(constdecl 18 in 1
)

(constdecl 19 while 1
)

(constdecl 20 if 1
)

(constdecl 21 elif 1
)

(constdecl 22 else 1
)

(constdecl 23 return 1
)

(constdecl 24 print 1
)

(funcdecl 25 append 1
)

(funcdecl 26 len 1
)

(funcdecl 27 open 1
)

(funcdecl 28 close 1
)

(funcdecl 29 xrange 1
)

(globaldecl 30 x 0
)


FILENAME: decl_simple.py

 CODE:

global_var =1
global_typed::int = 1
class class_external(parent): 
    instance_var = 1
    instanced_typed::int = 1

    def func_def(self):
        local_var = 1
        local_typed::int = 1

    def func_def_with_params(self, x):
        pass

    def func_def_with_multiparam(self, x, y, z):
        pass

    def func_def_with_typedparam(self, x::int):
        pass

    def func_def_nest1(self):

        def func_def_nest2():
            pass


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
getting param 3
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
global_var			GLOBAL_VAR	-> 30
global_typed			GLOBAL_VAR	-> 31
class_external			CLASS_DEC	-> 32
self			INSTANCE_VAR	-> 33
instance_var			INSTANCE_VAR	-> 34
instanced_typed			INSTANCE_VAR	-> 35
func_def			FUNC_DEC	-> 36
local_var			LOCAL_VAR	-> 37
local_typed			LOCAL_VAR	-> 38
func_def_with_params			FUNC_DEC	-> 39
x			PARAM_VAR	-> 40
func_def_with_multiparam			FUNC_DEC	-> 41
x			PARAM_VAR	-> 42
y			PARAM_VAR	-> 43
z			PARAM_VAR	-> 44
func_def_with_typedparam			FUNC_DEC	-> 45
x			PARAM_VAR	-> 46
func_def_nest1			FUNC_DEC	-> 47
func_def_nest2			FUNC_DEC	-> 48

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for global_var
adding global var global_var
found decl for global_var
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for global_typed
adding global var global_typed
found decl for global_typed
top of decorate
looking for decl for global_typed
found decl for global_typed

FILENAME: testAllocator.py

 CODE:
#simple allocation test with __init__
class AssaultClass(object):
    def __init__(self):
        self.weapon = "M16A3"
        self.gadget = "MedKit"
    
mySolder = AssaultClass()


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
AssaultClass			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init__			FUNC_DEC	-> 32
weapon			INSTANCE_VAR	-> 33
gadget			INSTANCE_VAR	-> 34
mySolder			GLOBAL_VAR	-> 35

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for AssaultClass
found decl for AssaultClass
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: testDeclare2.py

 CODE:
#multiple declarations, with IDs on the rhs
x = 4
y = 2
z = y


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
y			GLOBAL_VAR	-> 31
z			GLOBAL_VAR	-> 32

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for y
adding global var y
found decl for y
top of decorate
top of decorate
top of decorate
looking for decl for z
adding global var z
found decl for z
top of decorate
looking for decl for y
found decl for y
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 4
ID category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4


DAST OF testDeclare2.py

(module 0
    (assign 2
        (id 2 x)
        (int_literal 2 4))
    (assign 3
        (id 3 y)
        (int_literal 3 2))
    (assign 4
        (id 4 z)
        (id 4 y)))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31 32))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type 0
        (id 0 int)
        (type_list 0)))

(globaldecl 31 y 0
(type 0
        (id 0 int)
        (type_list 0)))

(globaldecl 32 z 0
(type 0
        (id 0 int)
        (type_list 0)))


FILENAME: testDeclare3.py

 CODE:
#for loop declaration
lst = [1, 2, 3]
for l in lst:
    print l
    

COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
FOR SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
lst			GLOBAL_VAR	-> 30
l			GLOBAL_VAR	-> 31

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for lst
adding global var lst
found decl for lst
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for l
found decl for l
top of decorate
looking for decl for lst
found decl for lst
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for l
found decl for l
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
INT allowed: 4
INT category: 4
top of type inference
INT allowed: 4
INT category: 4
top of type inference
INT allowed: 4
INT category: 4
before: 0
before: 32
before: 0
before: 32
after: 0
after: 32
after: 0
after: 32
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference


DAST OF testDeclare3.py

(module 0
    (assign 2
        (id 2 lst)
        (list_display 2
            (int_literal 2 1)
            (int_literal 2 2)
            (int_literal 2 3)))
    (for 3
        (id 3 l)
        (id 3 lst)
        (stmt_list 4
            (println 4
                ()
                (expr_list 4
                    (id 4 l))))
        (stmt_list 0)))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 lst 0
(type_var 0 (id 0 $_31)))

(globaldecl 31 l 0
(type_var 0 (id 0 $_27)))


FILENAME: testDeclare4.py

 CODE:
#parameter declarations
x = 5
class foo(Object):
    def f(z, y, p, n):
        print x+n
    f(3)


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






zSelf is not first param: ERRORPARAM SYNTAX
getting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
getting param 3
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
foo			CLASS_DEC	-> 31
self			INSTANCE_VAR	-> 32
f			FUNC_DEC	-> 33
z			PARAM_VAR	-> 34
y			PARAM_VAR	-> 35
p			PARAM_VAR	-> 36
n			PARAM_VAR	-> 37

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
looking for decl for n
found decl for n
top of decorate
top of decorate
looking for decl for f
found decl for f
top of decorate
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 4
ID category: 4
top of type inference
ID allowed: 32
ID category: 0

FILENAME: nestedLambda.py

 CODE:
def f():
  return lambda x: lambda y: x*y


COMMAND OUTPUT

DEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
f			FUNC_DEC	-> 30
__lambda0__			FUNC_DEC	-> 31
x			PARAM_VAR	-> 32
__lambda1__			FUNC_DEC	-> 33
y			PARAM_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
scoping in from def, new decl region is: __lambda1__
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0

FILENAME: testDeclare5.py

 CODE:
#local with same varname as global
#param with same varname as global
j = "global"
def p(j):
    print j
    
def d():
    j = "local"
    print j

d()


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
j			GLOBAL_VAR	-> 30
p			FUNC_DEC	-> 31
j			PARAM_VAR	-> 32
d			FUNC_DEC	-> 33
j			LOCAL_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for j
adding global var j
found decl for j
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for p
found decl for p
scoping in from def, new decl region is: p
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for j
found decl for j
top of decorate
top of decorate
looking for decl for d
found decl for d
scoping in from def, new decl region is: d
top of decorate
top of decorate
top of decorate
looking for decl for j
found decl for j
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for j
found decl for j
top of decorate
top of decorate
looking for decl for d
found decl for d
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
STR allowed: 8
STR category: 8
before: 8
before: 8
before: 0
before: 32
after: 8
after: 8
after: 8
after: 8
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
STR allowed: 8
STR category: 8
before: 8
before: 8
before: 0
before: 32
after: 8
after: 8
after: 8
after: 8
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 8
ID category: 8
top of type inference


DAST OF testDeclare5.py

(module 0
    (assign 3
        (id 3 j)
        (string_literal 3 "global"))
    (def 4
        (id 4 p)
        (formals_list 4
            (id 4 j))
        ()
        (block 5
            (println 5
                ()
                (expr_list 5
                    (id 5 j)))))
    (def 7
        (id 7 d)
        (formals_list 0)
        ()
        (block 8
            (assign 8
                (id 8 j)
                (string_literal 8 "local"))
            (println 9
                ()
                (expr_list 9
                    (id 9 j)))))
    (call 11
        (id 11 d)
        (expr_list 0)))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31 33))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 j 0
(type 0
        (id 0 str)
        (type_list 0)))

(funcdecl 31 p 0
(type_var 0 (id 0 $_30))
(index_list 32))

(paramdecl 32 j 31 0
(type_var 0 (id 0 $_31)))

(funcdecl 33 d 0
(type_var 0 (id 0 $_35))
(index_list 34))

(localdecl 34 j 33
(type 0
        (id 0 str)
        (type_list 0)))


FILENAME: testDeclare6.py

 CODE:
#multiple assignments to same var
x = 3
x = 4
y = 9
def f(y, j, p):
    y = 2
    y = 3
    print y
    
f(1)


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
getting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
y			GLOBAL_VAR	-> 31
f			FUNC_DEC	-> 32
y			PARAM_VAR	-> 33
j			PARAM_VAR	-> 34
p			PARAM_VAR	-> 35

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for y
adding global var y
found decl for y
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
top of decorate
looking for decl for f
found decl for f
top of decorate
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 4
ID category: 4
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 4
before: 4
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 4
ID category: 4
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 4
before: 4
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 4
ID category: 4
top of type inference


DAST OF testDeclare6.py

(module 0
    (assign 2
        (id 2 x)
        (int_literal 2 3))
    (assign 3
        (id 3 x)
        (int_literal 3 4))
    (assign 4
        (id 4 y)
        (int_literal 4 9))
    (def 5
        (id 5 f)
        (formals_list 5
            (id 5 y)
            (id 5 j)
            (id 5 p))
        ()
        (block 6
            (assign 6
                (id 6 y)
                (int_literal 6 2))
            (assign 7
                (id 7 y)
                (int_literal 7 3))
            (println 8
                ()
                (expr_list 8
                    (id 8 y)))))
    (call 10
        (id 10 f)
        (expr_list 10
            (int_literal 10 1))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31 32))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type 0
        (id 0 int)
        (type_list 0)))

(globaldecl 31 y 0
(type 0
        (id 0 int)
        (type_list 0)))

(funcdecl 32 f 0
(type_var 0 (id 0 $_36))
(index_list 33 34 35))

(paramdecl 33 y 32 0
(type 0
        (id 0 int)
        (type_list 0)))

(paramdecl 34 j 32 1
(type_var 0 (id 0 $_27)))

(paramdecl 35 p 32 2
(type_var 0 (id 0 $_28)))


FILENAME: testDecorateClass.py

 CODE:
class A(object):
	x = 2

class B(object):
	c = 2
	

COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
A			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
B			CLASS_DEC	-> 33
self			INSTANCE_VAR	-> 34
c			INSTANCE_VAR	-> 35

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for A
found decl for A
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for B
found decl for B
top of decorate
top of decorate
top of decorate
looking for decl for c
found decl for c
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4


DAST OF testDecorateClass.py

(module 0
    (class 1
        (id 1 A)
        (id 1 object)
        (block 2
            (assign 2
                (id 2 x)
                (int_literal 2 2))))
    (class 4
        (id 4 B)
        (id 4 object)
        (block 5
            (assign 5
                (id 5 c)
                (int_literal 5 2)))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 33))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 A 0
(type_var 0 (id 0 $_24))
(index_list 31 32))

(instancedecl 31 self 30
(type 0))

(instancedecl 32 x 30
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 33 B 0
(type_var 0 (id 0 $_26))
(index_list 34 35))

(instancedecl 34 self 33
(type 0))

(instancedecl 35 c 33
(type 0
        (id 0 int)
        (type_list 0)))


FILENAME: testDecorateDefArg.py

 CODE:
x = 2
def f(x):
	y = x


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
f			FUNC_DEC	-> 31
x			PARAM_VAR	-> 32
y			LOCAL_VAR	-> 33

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for x
found decl for x
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
before: 0
before: 32
before: 0
before: 32
after: 0
after: 32
after: 0
after: 32


DAST OF testDecorateDefArg.py

(module 0
    (assign 1
        (id 1 x)
        (int_literal 1 2))
    (def 2
        (id 2 f)
        (formals_list 2
            (id 2 x))
        ()
        (block 3
            (assign 3
                (id 3 y)
                (id 3 x)))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type 0
        (id 0 int)
        (type_list 0)))

(funcdecl 31 f 0
(type_var 0 (id 0 $_28))
(index_list 32 33))

(paramdecl 32 x 31 0
(type_var 0 (id 0 $_30)))

(localdecl 33 y 31
(type_var 0 (id 0 $_30)))


FILENAME: testAttribute.py

 CODE:
#multiple attribution
class A(object):
    x = 4

class B(object):
    c = A()
    
j = B.c.x


COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
A			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
B			CLASS_DEC	-> 33
self			INSTANCE_VAR	-> 34
c			INSTANCE_VAR	-> 35
j			GLOBAL_VAR	-> 36

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for A
found decl for A
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for B
found decl for B
top of decorate
top of decorate
top of decorate
looking for decl for c
found decl for c
top of decorate
top of decorate
looking for decl for A
found decl for A
top of decorate
top of decorate
top of decorate
looking for decl for j
adding global var j
found decl for j
top of decorate
top of decorate
looking for decl for B
found decl for B

FILENAME: self2.py

 CODE:
class foo(Object):
    x = 2
    
    def f1(self):
        def f2():
            print self.x
        print self.x




COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate
looking for decl for f2
found decl for f2
scoping in from def, new decl region is: f2
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate

FILENAME: testMethod2.py

 CODE:
#multiple methods with mutations, parameters, and return values
print "hello! this is a friendly test"

class UnfriendlyTest(object):
    
    def __init__(self):
        self.friendly = False
        self.anger = 9001
        
    def setAnger(self, val):
        self.anger = val
        return self.anger
    
    def feed(self):
        self.friendly = True
        

COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
UnfriendlyTest			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init__			FUNC_DEC	-> 32
friendly			INSTANCE_VAR	-> 33
anger			INSTANCE_VAR	-> 34
setAnger			FUNC_DEC	-> 35
val			PARAM_VAR	-> 36
feed			FUNC_DEC	-> 37

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for UnfriendlyTest
found decl for UnfriendlyTest
top of decorate
top of decorate
top of decorate
looking for decl for __init__
found decl for __init__
scoping in from def, new decl region is: __init__
top of decorate
top of decorate
top of decorate

FILENAME: testMethods.py

 CODE:
#simple method test
class banana(object):
    haspeel = True
    
    def peel(self):
        haspeel = False
        

COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
banana			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
haspeel			INSTANCE_VAR	-> 32
peel			FUNC_DEC	-> 33
haspeel			LOCAL_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for banana
found decl for banana
top of decorate
top of decorate
top of decorate
looking for decl for haspeel
found decl for haspeel
top of decorate
looking for decl for True

FILENAME: testAllocator6.py

 CODE:
#simple no init class instantiation
class Test(object):
    x = 2

test = Test();


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
Test			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
test			GLOBAL_VAR	-> 33

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for Test
found decl for Test
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for test
adding global var test
found decl for test
top of decorate
top of decorate
looking for decl for Test
found decl for Test
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
ID allowed: 32
ID category: 0
before: 0
before: 32
before: 0
before: 32
after: 0
after: 32
after: 0
after: 32


DAST OF testAllocator6.py

(module 0
    (class 2
        (id 2 Test)
        (id 2 object)
        (block 3
            (assign 3
                (id 3 x)
                (int_literal 3 2))))
    (assign 5
        (id 5 test)
        (new 5
            (id 5 Test))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 33))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 Test 0
(type_var 0 (id 0 $_27))
(index_list 31 32))

(instancedecl 31 self 30
(type 0))

(instancedecl 32 x 30
(type 0
        (id 0 int)
        (type_list 0)))

(globaldecl 33 test 0
(type_var 0 (id 0 $_37)))


FILENAME: testDecorateScope.py

 CODE:
x = 2
def f():
    y = x
    

COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
f			FUNC_DEC	-> 31
y			LOCAL_VAR	-> 32

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for x
found decl for x
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 4
ID category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4


DAST OF testDecorateScope.py

(module 0
    (assign 1
        (id 1 x)
        (int_literal 1 2))
    (def 2
        (id 2 f)
        (formals_list 0)
        ()
        (block 3
            (assign 3
                (id 3 y)
                (id 3 x)))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 x 0
(type 0
        (id 0 int)
        (type_list 0)))

(funcdecl 31 f 0
(type_var 0 (id 0 $_27))
(index_list 32))

(localdecl 32 y 31
(type 0
        (id 0 int)
        (type_list 0)))


FILENAME: overload.py

 CODE:
x::int = 2
x = 3
x::int = 4
x = 5
x = 6


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
looking for decl for x
found decl for x

FILENAME: self.py

 CODE:
class foo(Object):
    x = 2
    
    def f(self):
        print self.x


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f			FUNC_DEC	-> 33

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate

FILENAME: self3.py

 CODE:
class foo(Object):
    x = 2
    
    def f1(self):
        def f2():
            print self.x
        print self.x
    x = "string"



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate
looking for decl for f2
found decl for f2
scoping in from def, new decl region is: f2
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate

FILENAME: overload2.py

 CODE:
x::str = "meow"
x::int = 2


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
looking for decl for x
found decl for x

FILENAME: self4.py

 CODE:
class foo(Object):
    x = 2
    
    def f1(self):
        self.x = 4
        def f2():
            print self.x
        print self.x



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate

FILENAME: multiassign2.py

 CODE:
x::int,y::str = 2, "meow"


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
DEFAULT SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
TYPED_ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30
y			GLOBAL_VAR	-> 31

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
looking for decl for x
found decl for x

FILENAME: overload3.py

 CODE:
class foo(Object):
    
    def x(self):
        self.x = 2

a = foo()
a.x


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ATTRIBUTEREF SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			FUNC_DEC	-> 32
x			INSTANCE_VAR	-> 33
a			GLOBAL_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
scoping in from def, new decl region is: x
top of decorate
top of decorate
top of decorate

FILENAME: self5.py

 CODE:
class foo(Object):
    x = 2
    
    def f1(self):
        self.x = "string"
        def f2():
            print self.x
        print self.x



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate

FILENAME: multiassign3.py

 CODE:
class foo(Object):
    def __init(self):
        self.x, self.y = 2, 3


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__init			FUNC_DEC	-> 32
x			INSTANCE_VAR	-> 33
y			INSTANCE_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for __init
found decl for __init
scoping in from def, new decl region is: __init
top of decorate
top of decorate
top of decorate
top of decorate

FILENAME: self6.py

 CODE:
class foo(Object):
    x = [2, 3, 4]
    
    def f1(self):
        def f2():
            print self.x
        print self.x



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate
looking for decl for f2
found decl for f2
scoping in from def, new decl region is: f2
top of decorate
top of decorate
top of decorate
top of decorate
top of decorate

FILENAME: overload4.py

 CODE:
class foo(OBject):

    def __lambda0__(self):
        pass

    lambda self: self


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
__lambda0__			FUNC_DEC	-> 33

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
looking for decl for self
found decl for self
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0


DAST OF overload4.py

(module 0
    (class 1
        (id 1 foo)
        (id 1 OBject)
        (block 3
            (def 0
                (id 0 __lambda0__)
                (formals_list 6
                    (id 6 self))
                ()
                (block 6
                    (id 6 self)))
            (def 3
                (id 3 __lambda0__)
                (formals_list 3
                    (id 3 self))
                ()
                (block 0
                    (stmt_list 0)))
            (id 0 __lambda0__))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 foo 0
(type_var 0 (id 0 $_28))
(index_list 31 32 33))

(instancedecl 31 self 30
(type_var 0 (id 0 $_30)))

(funcdecl 32 __lambda0__ 30
(type_var 0 (id 0 $_32)))

(funcdecl 33 __lambda0__ 30
(function_type 0
        (type_var 0 (id 0 $_26))
        (type_list 0)))


FILENAME: self7.py

 CODE:
class foo(Object):
    x::dict = { bool: int}
    
    def f1(self):
        def f2():
            print self.x
        print self.x



COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
x			INSTANCE_VAR	-> 32
f1			FUNC_DEC	-> 33
f2			FUNC_DEC	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
looking for decl for x
found decl for x

FILENAME: multiassign4.py

 CODE:
class foo(Object):
    y = 2
    def __init(self):
        self.x = y = 3


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ASSIGN SYNTAX
ATTRIBUTEREF SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
y			INSTANCE_VAR	-> 32
__init			FUNC_DEC	-> 33
x			INSTANCE_VAR	-> 34

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
top of decorate
top of decorate
looking for decl for __init
found decl for __init
scoping in from def, new decl region is: __init
top of decorate
top of decorate
top of decorate

FILENAME: overload5.py

 CODE:
append = 2
bool = "meow"
int = 2



COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
append			GLOBAL_VAR	-> 30
bool			GLOBAL_VAR	-> 31
int			GLOBAL_VAR	-> 32

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for append
adding global var append
found decl for append
top of decorate
top of decorate
top of decorate
looking for decl for bool
adding global var bool
found decl for bool
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for int
adding global var int
found decl for int
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
STR allowed: 8
STR category: 8
before: 8
before: 8
before: 0
before: 32
after: 8
after: 8
after: 8
after: 8
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4


DAST OF overload5.py

(module 0
    (assign 1
        (id 1 append)
        (int_literal 1 2))
    (assign 2
        (id 2 bool)
        (string_literal 2 "meow"))
    (assign 3
        (id 3 int)
        (int_literal 3 2)))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30 31 32))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(globaldecl 30 append 0
(type 0
        (id 0 int)
        (type_list 0)))

(globaldecl 31 bool 0
(type 0
        (id 0 str)
        (type_list 0)))

(globaldecl 32 int 0
(type 0
        (id 0 int)
        (type_list 0)))


FILENAME: overload6.py

 CODE:
class stderr(Object):
    stdin = 2

    def argv(self, xrange, meow):
        pass


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfgetting param 1
PARAM SYNTAX
getting param 2
PARAM SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
stderr			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
stdin			INSTANCE_VAR	-> 32
argv			FUNC_DEC	-> 33
xrange			PARAM_VAR	-> 34
meow			PARAM_VAR	-> 35

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for stderr
found decl for stderr
top of decorate
top of decorate
top of decorate
looking for decl for stdin
found decl for stdin
top of decorate
top of decorate
top of decorate
looking for decl for argv
found decl for argv
scoping in from def, new decl region is: argv
top of decorate
top of decorate
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
 - assign statement start
top of type inference
ID allowed: 32
ID category: 0
top of type inference
INT allowed: 4
INT category: 4
before: 4
before: 4
before: 0
before: 32
after: 4
after: 4
after: 4
after: 4
top of type inference
top of type inference


DAST OF overload6.py

(module 0
    (class 1
        (id 1 stderr)
        (id 1 Object)
        (block 2
            (assign 2
                (id 2 stdin)
                (int_literal 2 2))
            (def 4
                (id 4 argv)
                (formals_list 4
                    (id 4 self)
                    (id 4 xrange)
                    (id 4 meow))
                ()
                (block 0
                    (stmt_list 0))))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 stderr 0
(type_var 0 (id 0 $_28))
(index_list 31 32 33))

(instancedecl 31 self 30
(type 0))

(instancedecl 32 stdin 30
(type 0
        (id 0 int)
        (type_list 0)))

(funcdecl 33 argv 30
(type_var 0 (id 0 $_30))
(index_list 34 35))

(paramdecl 34 xrange 33 1
(type_var 0 (id 0 $_26)))

(paramdecl 35 meow 33 2
(type_var 0 (id 0 $_27)))


FILENAME: overload7.py

 CODE:
x::list = [str, bool, int]


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
x			GLOBAL_VAR	-> 30

end decl_set contents

top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for x
adding global var x
found decl for x
top of decorate
looking for decl for x
found decl for x

FILENAME: overload8.py

 CODE:
y = 2
if y > 0:
    x::str = "meow"
elif y == 0:
    x::list = []
else:
    x::int = 2


COMMAND OUTPUT

DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
TYPED_ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
y			GLOBAL_VAR	-> 30
x			GLOBAL_VAR	-> 31

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for y
adding global var y
found decl for y
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for >

FILENAME: testLambda4.py

 CODE:
lambda y: lambda x: x


COMMAND OUTPUT

DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
__lambda0__			FUNC_DEC	-> 30
y			PARAM_VAR	-> 31
__lambda1__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
scoping in from def, new decl region is: __lambda1__
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda4.py

(module 0
    (def 0
        (id 0 __lambda0__)
        (formals_list 1
            (id 1 y))
        ()
        (block 0
            (def 0
                (id 0 __lambda1__)
                (formals_list 1
                    (id 1 x))
                ()
                (block 1
                    (id 1 x)))
            (id 0 __lambda1__)))
    (id 0 __lambda0__))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(funcdecl 30 __lambda0__ 0
(type_var 0 (id 0 $_32))
(index_list 31 32))

(paramdecl 31 y 30 0
(type_var 0 (id 0 $_24)))

(funcdecl 32 __lambda1__ 30
(type_var 0 (id 0 $_31))
(index_list 33))

(paramdecl 33 x 32 0
(type_var 0 (id 0 $_30)))


FILENAME: testLambda5.py

 CODE:
class foo(OBject):

    lambda x: lambda y :y


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






xSelf is not first param: ERRORPARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
__lambda1__			FUNC_DEC	-> 34
y			PARAM_VAR	-> 35

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
scoping in from def, new decl region is: __lambda1__
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda5.py

(module 0
    (class 1
        (id 1 foo)
        (id 1 OBject)
        (block 3
            (def 0
                (id 0 __lambda0__)
                (formals_list 3
                    (id 3 x))
                ()
                (block 0
                    (def 0
                        (id 0 __lambda1__)
                        (formals_list 3
                            (id 3 y))
                        ()
                        (block 3
                            (id 3 y)))
                    (id 0 __lambda1__)))
            (id 0 __lambda0__))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 foo 0
(type_var 0 (id 0 $_28))
(index_list 31 32))

(instancedecl 31 self 30
(type 0))

(funcdecl 32 __lambda0__ 30
(type_var 0 (id 0 $_33))
(index_list 33 34))

(paramdecl 33 x 32 0
(type_var 0 (id 0 $_24)))

(funcdecl 34 __lambda1__ 32
(type_var 0 (id 0 $_32))
(index_list 35))

(paramdecl 35 y 34 0
(type_var 0 (id 0 $_31)))


FILENAME: testMultipleAttribute.py

 CODE:
class A(object):
    y = 1
class B(object):
    def g():
        return x
    x = A()
f = B.g().y


COMMAND OUTPUT

begin
end
begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
ASSIGN SYNTAX
ID SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
DEFAULT SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX
ASSIGN SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
A			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
y			INSTANCE_VAR	-> 32
B			CLASS_DEC	-> 33
self			INSTANCE_VAR	-> 34
g			FUNC_DEC	-> 35
x			INSTANCE_VAR	-> 36
f			GLOBAL_VAR	-> 37

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for A
found decl for A
top of decorate
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
top of decorate
top of decorate
looking for decl for B
found decl for B
top of decorate
top of decorate
top of decorate
looking for decl for g
found decl for g
scoping in from def, new decl region is: g
top of decorate
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
looking for decl for A
found decl for A
top of decorate
top of decorate
top of decorate
looking for decl for f
adding global var f
found decl for f
top of decorate
top of decorate

FILENAME: testLambda6.py

 CODE:
class foo(Object):

    def f(self):
        lambda x: lambda y:y


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






xSelf is not first param: ERRORPARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
__lambda1__			FUNC_DEC	-> 34
y			PARAM_VAR	-> 35
f			FUNC_DEC	-> 36

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
scoping in from def, new decl region is: __lambda1__
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda6.py

(module 0
    (class 1
        (id 1 foo)
        (id 1 Object)
        (block 3
            (def 0
                (id 0 __lambda0__)
                (formals_list 4
                    (id 4 x))
                ()
                (block 0
                    (def 0
                        (id 0 __lambda1__)
                        (formals_list 4
                            (id 4 y))
                        ()
                        (block 4
                            (id 4 y)))
                    (id 0 __lambda1__)))
            (def 3
                (id 3 f)
                (formals_list 3
                    (id 3 self))
                ()
                (block 4
                    (id 0 __lambda0__))))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 foo 0
(type_var 0 (id 0 $_31))
(index_list 31 32 36))

(instancedecl 31 self 30
(type 0))

(funcdecl 32 __lambda0__ 30
(type_var 0 (id 0 $_37))
(index_list 33 34))

(paramdecl 33 x 32 0
(type_var 0 (id 0 $_24)))

(funcdecl 34 __lambda1__ 32
(type_var 0 (id 0 $_35))
(index_list 35))

(paramdecl 35 y 34 0
(type_var 0 (id 0 $_34)))

(funcdecl 36 f 30
(type_var 0 (id 0 $_36)))


FILENAME: testLambda7.py

 CODE:
class foo(OBject):

    def f1(self):
        pass

    def f2(self):
        pass

    def f3(self):
        lambda x:x


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






xSelf is not first param: ERRORPARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
__lambda0__			FUNC_DEC	-> 32
x			PARAM_VAR	-> 33
f1			FUNC_DEC	-> 34
f2			FUNC_DEC	-> 35
f3			FUNC_DEC	-> 36

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
looking for decl for x
found decl for x
top of decorate
top of decorate
looking for decl for f1
found decl for f1
scoping in from def, new decl region is: f1
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for f2
found decl for f2
scoping in from def, new decl region is: f2
top of decorate
top of decorate
top of decorate
top of decorate
looking for decl for f3
found decl for f3
scoping in from def, new decl region is: f3
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda7.py

(module 0
    (class 1
        (id 1 foo)
        (id 1 OBject)
        (block 3
            (def 0
                (id 0 __lambda0__)
                (formals_list 10
                    (id 10 x))
                ()
                (block 10
                    (id 10 x)))
            (def 3
                (id 3 f1)
                (formals_list 3
                    (id 3 self))
                ()
                (block 0
                    (stmt_list 0)))
            (def 6
                (id 6 f2)
                (formals_list 6
                    (id 6 self))
                ()
                (block 0
                    (stmt_list 0)))
            (def 9
                (id 9 f3)
                (formals_list 9
                    (id 9 self))
                ()
                (block 10
                    (id 0 __lambda0__))))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 foo 0
(type_var 0 (id 0 $_34))
(index_list 31 32 34 35 36))

(instancedecl 31 self 30
(type 0))

(funcdecl 32 __lambda0__ 30
(type_var 0 (id 0 $_40))
(index_list 33))

(paramdecl 33 x 32 0
(type_var 0 (id 0 $_36)))

(funcdecl 34 f1 30
(type_var 0 (id 0 $_37)))

(funcdecl 35 f2 30
(type_var 0 (id 0 $_38)))

(funcdecl 36 f3 30
(type_var 0 (id 0 $_39)))


FILENAME: testLambda8.py

 CODE:
class foo(Object):

    def f(self):
        def f2(self):
            lambda x: lambda y:y


COMMAND OUTPUT

begin
end
DEFAULT SYNTAX
CLASS SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0






selfDEFAULT SYNTAX
DEFF SYNTAX
getting param 0
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
DEFF SYNTAX
getting param 0
PARAM SYNTAX
DEFAULT SYNTAX
ID SYNTAX
ID SYNTAX
ID SYNTAX

decl_set contents: 

__main__		MODULE_DEC	-> 0
__builtin__		MODULE_DEC	-> 1
int			CLASS_DEC	-> 2
bool			CLASS_DEC	-> 3
file			CLASS_DEC	-> 4
str			CLASS_DEC	-> 5
range			CLASS_DEC	-> 6
list			CLASS_DEC	-> 7
tuple			CLASS_DEC	-> 8
dict			CLASS_DEC	-> 9
None			CONST_VAR	-> 10
True			CONST_VAR	-> 11
False			CONST_VAR	-> 12
stdout			CONST_VAR	-> 13
stdin			CONST_VAR	-> 14
stderr			CONST_VAR	-> 15
argv			CONST_VAR	-> 16
for			CONST_VAR	-> 17
in			CONST_VAR	-> 18
while			CONST_VAR	-> 19
if			CONST_VAR	-> 20
elif			CONST_VAR	-> 21
else			CONST_VAR	-> 22
return			CONST_VAR	-> 23
print			CONST_VAR	-> 24
append			FUNC_DEC	-> 25
len			FUNC_DEC	-> 26
open			FUNC_DEC	-> 27
close			FUNC_DEC	-> 28
xrange			FUNC_DEC	-> 29
foo			CLASS_DEC	-> 30
self			INSTANCE_VAR	-> 31
f			FUNC_DEC	-> 32
f2			FUNC_DEC	-> 33
__lambda0__			FUNC_DEC	-> 34
x			PARAM_VAR	-> 35
__lambda1__			FUNC_DEC	-> 36
y			PARAM_VAR	-> 37

end decl_set contents

top of decorate
top of decorate
top of decorate
looking for decl for foo
found decl for foo
top of decorate
top of decorate
top of decorate
looking for decl for f
found decl for f
scoping in from def, new decl region is: f
top of decorate
top of decorate
top of decorate
looking for decl for f2
found decl for f2
scoping in from def, new decl region is: f2
top of decorate
top of decorate
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
scoping in from def, new decl region is: __lambda0__
top of decorate
top of decorate
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
scoping in from def, new decl region is: __lambda1__
top of decorate
top of decorate
looking for decl for y
found decl for y
top of decorate
looking for decl for __lambda1__
found decl for __lambda1__
top of decorate
looking for decl for __lambda0__
found decl for __lambda0__
 --- BEGIN TYPE INFERENCE --- 
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0
top of type inference
ID allowed: 32
ID category: 0


DAST OF testLambda8.py

(module 0
    (class 1
        (id 1 foo)
        (id 1 Object)
        (block 3
            (def 3
                (id 3 f)
                (formals_list 3
                    (id 3 self))
                ()
                (block 4
                    (def 4
                        (id 4 f2)
                        (formals_list 4
                            (id 4 self))
                        ()
                        (block 5
                            (def 0
                                (id 0 __lambda0__)
                                (formals_list 5
                                    (id 5 x))
                                ()
                                (block 0
                                    (def 0
                                        (id 0 __lambda1__)
                                        (formals_list 5
                                            (id 5 y))
                                        ()
                                        (block 5
                                            (id 5 y)))
                                    (id 0 __lambda1__)))
                            (id 0 __lambda0__))))))))
(moduledecl 0 __main__
(type_var 0 (id 0 $_0))
(index_list 30))

(moduledecl 1 __builtin__
(type_var 0 (id 0 $_1))
(index_list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29))

(classdecl 2 int 1
(type 0
        (id 0 int)
        (type_list 0)))

(classdecl 3 bool 1
(type 0
        (id 0 bool)
        (type_list 0)))

(classdecl 4 file 1
(type 0
        (id 0 file)
        (type_list 0)))

(classdecl 5 str 1
(type 0
        (id 0 str)
        (type_list 0)))

(classdecl 6 range 1
(type 0
        (id 0 range)
        (type_list 0)))

(classdecl 7 list 1
(type 0
        (id 0 list)
        (type_list 0)))

(classdecl 8 tuple 1
(type 0
        (id 0 tuple)
        (type_list 0)))

(classdecl 9 dict 1
(type 0
        (id 0 dict)
        (type_list 0)))

(constdecl 10 None 1
(type_var 0 (id 0 $_2)))

(constdecl 11 True 1
(type_var 0 (id 0 $_3)))

(constdecl 12 False 1
(type_var 0 (id 0 $_4)))

(constdecl 13 stdout 1
(type_var 0 (id 0 $_5)))

(constdecl 14 stdin 1
(type_var 0 (id 0 $_6)))

(constdecl 15 stderr 1
(type_var 0 (id 0 $_7)))

(constdecl 16 argv 1
(type_var 0 (id 0 $_8)))

(constdecl 17 for 1
(type_var 0 (id 0 $_9)))

(constdecl 18 in 1
(type_var 0 (id 0 $_10)))

(constdecl 19 while 1
(type_var 0 (id 0 $_11)))

(constdecl 20 if 1
(type_var 0 (id 0 $_12)))

(constdecl 21 elif 1
(type_var 0 (id 0 $_13)))

(constdecl 22 else 1
(type_var 0 (id 0 $_14)))

(constdecl 23 return 1
(type_var 0 (id 0 $_15)))

(constdecl 24 print 1
(type_var 0 (id 0 $_16)))

(funcdecl 25 append 1
(type_var 0 (id 0 $_17)))

(funcdecl 26 len 1
(type_var 0 (id 0 $_18)))

(funcdecl 27 open 1
(type_var 0 (id 0 $_19)))

(funcdecl 28 close 1
(type_var 0 (id 0 $_20)))

(funcdecl 29 xrange 1
(type_var 0 (id 0 $_21)))

(classdecl 30 foo 0
(type_var 0 (id 0 $_34))
(index_list 31 32))

(instancedecl 31 self 30
(type 0))

(funcdecl 32 f 30
(type_var 0 (id 0 $_35))
(index_list 33))

(funcdecl 33 f2 32
(type_var 0 (id 0 $_36))
(index_list 34))

(funcdecl 34 __lambda0__ 33
(type_var 0 (id 0 $_41))
(index_list 35 36))

(paramdecl 35 x 34 0
(type_var 0 (id 0 $_30)))

(funcdecl 36 __lambda1__ 34
(type_var 0 (id 0 $_40))
(index_list 37))

(paramdecl 37 y 36 0
(type_var 0 (id 0 $_39)))

